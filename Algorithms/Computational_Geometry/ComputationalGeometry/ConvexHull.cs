using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections;

/*
 * Convex Hull
 * 
 * Given a set of points, find a convex polygon that encompasses all the given points
 * 
 * Input : A set of points
 * Output : Points that form vertices of the convex hull
 * 
 * Convex hull is a convex polygon that encompasses within its area all the given points
 * 
 * Algorithm : Graham Scan
 * 
 * Complexity : O(nlogn) where n is the number of points
 * 
 * Complexity analysis:
 * Every point is considered once. Processing of all points completes in O(n)
 * Sorting of points happens in O(nlogn)
 * Hence, overall complexity is O(nlogn)
 * 
 * 
 * Properties of a convex poygon:
 * 1. Every internal angle of the polygon is less than 180 degrees
 * 2. Given any two points within the polygon, every part of the line connecting the points would be within the polygon
 *
 * 
 * Jarvis's march is the other popular algorithm to generate convex hull
 * Main idea of Jarvis march : for the lowest point, have a horizontal line pass through it and find the point that makes
 * least angle with this line and add this point to the list of vertices. To get eve4ry subsequent vertex, find the point making
 * smallest angle with line generated by extending the edge connnecing the last vertex and the second last vertex
 * Complexity : O(nh) where h is the number of vertices added to the convex hull.
 * In the worst case, all points might becomes vertices of the convex hull, in which case the complexity is O(n^2).
 * 
 * 
 * References:
 * http://cs.uwindsor.ca/~asishm/cs557/F10/handouts/lec2.pdf
 * 
 * Author : Shravana Aadith
 */



namespace Algorithms.ComputationalGeometry
{

    public class Point
    {
        public int x, y;
        public double PolarAngle;

        public Point(int x, int y)
        {
            this.x = x; this.y = y;
        }


        //gives the inclination (in radians) of the line
        //connecting the current point with the given point        
        public double GetPolarAngle(Point p)
        {
            //slope = dy/dx = tan(theta)
            //theta = arctan(dy/dx)

            double dx = Math.Abs(p.x - this.x);
            double dy=Math.Abs(p.y-this.y);
            if (dx == 0)
                return 0;
            double m=dy/dx;
            return Math.Atan(m);
        }
    }

    public class XCoordinateComparer : IComparer<Point>
    {
        public int Compare(Point a, Point b)
        {
            return a.x.CompareTo(b.x);            
        }
    }

    public class YCoordinateComparer : IComparer<Point>
    {
        public int Compare(Point a, Point b)
        {
            return a.y.CompareTo(b.y);
        }
    }

    
    public class PolarAngleBasedComparer : IComparer<Point>
    {
        public int Compare(Point a, Point b)
        {
            return a.PolarAngle.CompareTo(b.PolarAngle);
        }
    }



    public class ConvexHull
    {
        
        public static List<Point> GrahamScan(List<Point> Points)
        {
            
            int n = Points.Count;
            int NextPointToEvaluate = 0;
            List<Point> ConvexHullVertices = new List<Point>();
            int NumVertices = 0;

            //Step 1 : Sort the points by co-ordinates
            XCoordinateComparer xCoordinateComparer = new XCoordinateComparer();
            Points.Sort(xCoordinateComparer);

            YCoordinateComparer yCoordinateComparer = new YCoordinateComparer();
            Points.Sort(yCoordinateComparer);

            Point LowerMostLeftMost = Points[0];


            //Step 2 : Find the angle between horizontal line passing through the lowermost leftmost point
            //and the line connecting this point with every other point

            //Points.Remove(LowerMostLeftMost);
            
            foreach (Point p in Points)
            {
                p.PolarAngle = p.GetPolarAngle(LowerMostLeftMost);
            }


            //Step 3 : Sort the points by the polar angle they make with x-axis passing through
            //the lowermostleftmost point
            PolarAngleBasedComparer polarAngleBasedComparer = new PolarAngleBasedComparer();
            Points.Sort(polarAngleBasedComparer);

            //Step 4 : Add the first two points to the set of convex hull vertices 
            ConvexHullVertices.Add(Points[NextPointToEvaluate++]);
            NumVertices++;
            ConvexHullVertices.Add(Points[NextPointToEvaluate++]);
            NumVertices++;
            


            //Step 5:
            //for each point in the list
            for (; NextPointToEvaluate < n; NextPointToEvaluate++ )
            {
                Point CurrentPoint = Points[NextPointToEvaluate];

                //if the current point in combination to the last two vertices of convex hull results in a counter clockwise turn,
                //remove the last added vertex. Repeat this process until the current point in combination last two vertices does 
                //not result in counter clockwise turn
                while (!IsCounterClockwiseTurn(ConvexHullVertices[NumVertices - 2], ConvexHullVertices[NumVertices - 1], CurrentPoint))
                {
                    ConvexHullVertices.RemoveAt(NumVertices - 1);
                    NumVertices--;
                }

                //and then add the current point as a convex hull vertex
                ConvexHullVertices.Add(CurrentPoint);
                NumVertices++;

                //note : every single point in input will be added to the (partial-)result when this loop processes that point
                // later iteration of the loop will remove the point if it results in counterclockwise turn with respect to a
                //subsequent point

            }

            return ConvexHullVertices;
        }


        //uses cross product to check whether point c would result in counterclockwise turn
        //with respect to a and b
        public static bool IsCounterClockwiseTurn(Point a, Point b, Point c)
        {
            Point ab = new Point(b.x-a.x,b.y-a.y);
            Point bc = new Point(c.x-b.x,c.y-b.y);
            int cross_product = ab.x * bc.y - ab.y * bc.x;
            //if cross_product = 0, points are collinear
            //if cross_product < 0, points result in clockwise turn
            //if cross_product > 0, points result in counter-clockwise turn

            return cross_product > 0;
        }
    }


    public class ConvexHullClient
    {
        public static void Run()
        {
            List<Point> points = new List<Point>();

            points.Add(new Point(7, 6));
            points.Add(new Point(6, 3));
            points.Add(new Point(4, 2));
            points.Add(new Point(1, 1));
            points.Add(new Point(6, 1));
            points.Add(new Point(0, 3));
            List<Point> vertices = ConvexHull.GrahamScan(points);
        }
    }
}
